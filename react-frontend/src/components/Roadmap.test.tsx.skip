import React from 'react';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import '@testing-library/jest-dom';
import Roadmap from './Roadmap';
import { ThemeProvider } from '../contexts/ThemeContext';
import RoadmapService from '../services/roadmapService';

// Mock the RoadmapService
jest.mock('../services/roadmapService', () => ({
  __esModule: true,
  default: {
    getCurrentRoadmap: jest.fn(),
    updateRoadmapItem: jest.fn(),
    generateRoadmap: jest.fn(),
  },
}));

const mockOnClose = jest.fn();
const mockOnOpenChat = jest.fn();

const renderWithTheme = (component: React.ReactElement) => {
  return render(<ThemeProvider>{component}</ThemeProvider>);
};

const mockRoadmap = {
  id: 'roadmap-123',
  userId: 'user-123',
  startDate: '2025-10-16',
  endDate: '2026-01-14',
  items: [
    {
      id: 'item-1',
      title: 'Improve morning routine',
      description: 'Work on reducing meltdowns during morning transitions',
      category: 'daily_skills' as const,
      status: 'in_progress' as const,
      dueDate: '2025-11-15',
      notes: [],
    },
    {
      id: 'item-2',
      title: 'Practice social greetings',
      description: 'Learn to say hello and goodbye appropriately',
      category: 'social' as const,
      status: 'not_started' as const,
      dueDate: '2025-12-01',
      notes: [],
    },
    {
      id: 'item-3',
      title: 'Complete sensory assessment',
      description: 'Get professional evaluation of sensory needs',
      category: 'therapy' as const,
      status: 'completed' as const,
      dueDate: '2025-10-30',
      notes: ['Completed with OT', 'Report received'],
    },
  ],
  createdAt: '2025-10-16T00:00:00Z',
  updatedAt: '2025-10-16T00:00:00Z',
};

describe('Roadmap', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  describe('Loading State', () => {
    it('should show loading state initially', async () => {
      (RoadmapService.getCurrentRoadmap as jest.Mock).mockImplementation(
        () => new Promise(() => {}) // Never resolves
      );

      renderWithTheme(<Roadmap onClose={mockOnClose} onOpenChat={mockOnOpenChat} />);

      expect(screen.getByText(/Loading your roadmap/i)).toBeInTheDocument();
    });
  });

  describe('Empty State', () => {
    it('should show empty state when no roadmap exists', async () => {
      (RoadmapService.getCurrentRoadmap as jest.Mock).mockResolvedValue(null);

      renderWithTheme(<Roadmap onClose={mockOnClose} onOpenChat={mockOnOpenChat} />);

      await waitFor(() => {
        expect(screen.getByText(/No Active Roadmap/i)).toBeInTheDocument();
      });

      expect(screen.getByText(/Generate Roadmap/i)).toBeInTheDocument();
    });

    it('should call generateRoadmap when generate button is clicked', async () => {
      (RoadmapService.getCurrentRoadmap as jest.Mock).mockResolvedValue(null);
      (RoadmapService.generateRoadmap as jest.Mock).mockResolvedValue(mockRoadmap);

      renderWithTheme(<Roadmap onClose={mockOnClose} onOpenChat={mockOnOpenChat} />);

      await waitFor(() => {
        expect(screen.getByText(/Generate Roadmap/i)).toBeInTheDocument();
      });

      const generateButton = screen.getByText(/Generate Roadmap/i);
      fireEvent.click(generateButton);

      await waitFor(() => {
        expect(RoadmapService.generateRoadmap).toHaveBeenCalled();
      });
    });
  });

  describe('Roadmap Display', () => {
    beforeEach(() => {
      (RoadmapService.getCurrentRoadmap as jest.Mock).mockResolvedValue(mockRoadmap);
    });

    it('should display roadmap header with title', async () => {
      renderWithTheme(<Roadmap onClose={mockOnClose} onOpenChat={mockOnOpenChat} />);

      await waitFor(() => {
        expect(screen.getByText(/90-Day Roadmap/i)).toBeInTheDocument();
      });
    });

    it('should display progress information', async () => {
      renderWithTheme(<Roadmap onClose={mockOnClose} onOpenChat={mockOnOpenChat} />);

      await waitFor(() => {
        expect(screen.getByText(/goals/i)).toBeInTheDocument();
      });
    });

    it('should display all roadmap items', async () => {
      renderWithTheme(<Roadmap onClose={mockOnClose} onOpenChat={mockOnOpenChat} />);

      await waitFor(() => {
        expect(screen.getByText('Improve morning routine')).toBeInTheDocument();
        expect(screen.getByText('Practice social greetings')).toBeInTheDocument();
        expect(screen.getByText('Complete sensory assessment')).toBeInTheDocument();
      });
    });

    it('should show correct status badges for items', async () => {
      renderWithTheme(<Roadmap onClose={mockOnClose} onOpenChat={mockOnOpenChat} />);

      await waitFor(() => {
        expect(screen.getByText(/In Progress/i)).toBeInTheDocument();
        expect(screen.getByText(/Not Started/i)).toBeInTheDocument();
        expect(screen.getByText(/Completed/i)).toBeInTheDocument();
      });
    });

    it('should display category badges', async () => {
      renderWithTheme(<Roadmap onClose={mockOnClose} onOpenChat={mockOnOpenChat} />);

      await waitFor(() => {
        expect(screen.getByText(/Daily Skills/i)).toBeInTheDocument();
        expect(screen.getByText(/Social/i)).toBeInTheDocument();
        expect(screen.getByText(/Therapy/i)).toBeInTheDocument();
      });
    });

    it('should show due dates for items', async () => {
      renderWithTheme(<Roadmap onClose={mockOnClose} onOpenChat={mockOnOpenChat} />);

      await waitFor(() => {
        const dueDates = screen.getAllByText(/Due:/i);
        expect(dueDates.length).toBeGreaterThan(0);
      });
    });
  });

  describe('Item Status Toggle', () => {
    beforeEach(() => {
      (RoadmapService.getCurrentRoadmap as jest.Mock).mockResolvedValue(mockRoadmap);
      (RoadmapService.updateRoadmapItem as jest.Mock).mockResolvedValue({
        ...mockRoadmap.items[0],
        status: 'completed',
      });
    });

    it('should toggle item status when clicked', async () => {
      renderWithTheme(<Roadmap onClose={mockOnClose} onOpenChat={mockOnOpenChat} />);

      await waitFor(() => {
        expect(screen.getByText('Improve morning routine')).toBeInTheDocument();
      });

      const statusButton = screen.getByText(/In Progress/i).closest('button');
      if (statusButton) {
        fireEvent.click(statusButton);
      }

      await waitFor(() => {
        expect(RoadmapService.updateRoadmapItem).toHaveBeenCalledWith(
          'roadmap-123',
          'item-1',
          { status: 'completed' }
        );
      });
    });

    it('should show error message when status update fails', async () => {
      (RoadmapService.updateRoadmapItem as jest.Mock).mockRejectedValue(
        new Error('Update failed')
      );

      renderWithTheme(<Roadmap onClose={mockOnClose} onOpenChat={mockOnOpenChat} />);

      await waitFor(() => {
        expect(screen.getByText('Improve morning routine')).toBeInTheDocument();
      });

      const statusButton = screen.getByText(/In Progress/i).closest('button');
      if (statusButton) {
        fireEvent.click(statusButton);
      }

      await waitFor(() => {
        expect(screen.getByText(/Failed to update goal status/i)).toBeInTheDocument();
      });
    });
  });

  describe('Navigation and Actions', () => {
    beforeEach(() => {
      (RoadmapService.getCurrentRoadmap as jest.Mock).mockResolvedValue(mockRoadmap);
    });

    it('should have close button', async () => {
      renderWithTheme(<Roadmap onClose={mockOnClose} onOpenChat={mockOnOpenChat} />);

      await waitFor(() => {
        expect(screen.getByText(/90-Day Roadmap/i)).toBeInTheDocument();
      });

      const closeButton = screen.getByLabelText(/close/i);
      expect(closeButton).toBeInTheDocument();
    });

    it('should call onClose when close button is clicked', async () => {
      renderWithTheme(<Roadmap onClose={mockOnClose} onOpenChat={mockOnOpenChat} />);

      await waitFor(() => {
        expect(screen.getByText(/90-Day Roadmap/i)).toBeInTheDocument();
      });

      const closeButton = screen.getByLabelText(/close/i);
      fireEvent.click(closeButton);

      expect(mockOnClose).toHaveBeenCalled();
    });

    it('should have "Chat about Roadmap" button', async () => {
      renderWithTheme(<Roadmap onClose={mockOnClose} onOpenChat={mockOnOpenChat} />);

      await waitFor(() => {
        expect(screen.getByText(/Chat about Roadmap/i)).toBeInTheDocument();
      });
    });

    it('should call onOpenChat when chat button is clicked', async () => {
      renderWithTheme(<Roadmap onClose={mockOnClose} onOpenChat={mockOnOpenChat} />);

      await waitFor(() => {
        expect(screen.getByText(/Chat about Roadmap/i)).toBeInTheDocument();
      });

      const chatButton = screen.getByText(/Chat about Roadmap/i);
      fireEvent.click(chatButton);

      expect(mockOnOpenChat).toHaveBeenCalled();
    });

    it('should have "Add New Goal" button', async () => {
      renderWithTheme(<Roadmap onClose={mockOnClose} onOpenChat={mockOnOpenChat} />);

      await waitFor(() => {
        expect(screen.getByText(/Add New Goal/i)).toBeInTheDocument();
      });
    });
  });

  describe('Category Filtering', () => {
    beforeEach(() => {
      (RoadmapService.getCurrentRoadmap as jest.Mock).mockResolvedValue(mockRoadmap);
    });

    it('should display all categories', async () => {
      renderWithTheme(<Roadmap onClose={mockOnClose} onOpenChat={mockOnOpenChat} />);

      await waitFor(() => {
        expect(screen.getByText(/All/i)).toBeInTheDocument();
        expect(screen.getByText(/Therapy/i)).toBeInTheDocument();
        expect(screen.getByText(/Education/i)).toBeInTheDocument();
        expect(screen.getByText(/Daily Skills/i)).toBeInTheDocument();
        expect(screen.getByText(/Social/i)).toBeInTheDocument();
      });
    });

    it('should filter items when category is selected', async () => {
      renderWithTheme(<Roadmap onClose={mockOnClose} onOpenChat={mockOnOpenChat} />);

      await waitFor(() => {
        expect(screen.getByText('Improve morning routine')).toBeInTheDocument();
      });

      // Click on Social category
      const socialButton = screen.getByText(/Social/i).closest('button');
      if (socialButton) {
        fireEvent.click(socialButton);
      }

      await waitFor(() => {
        // Social item should be visible
        expect(screen.getByText('Practice social greetings')).toBeInTheDocument();
        // Non-social items should not be visible
        expect(screen.queryByText('Improve morning routine')).not.toBeInTheDocument();
      });
    });
  });

  describe('Notes Display', () => {
    beforeEach(() => {
      (RoadmapService.getCurrentRoadmap as jest.Mock).mockResolvedValue(mockRoadmap);
    });

    it('should display notes for items that have them', async () => {
      renderWithTheme(<Roadmap onClose={mockOnClose} onOpenChat={mockOnOpenChat} />);

      await waitFor(() => {
        expect(screen.getByText('Complete sensory assessment')).toBeInTheDocument();
      });

      // Check if notes are displayed (they might be in a collapsed state initially)
      const item = screen.getByText('Complete sensory assessment').closest('div');
      expect(item).toBeInTheDocument();
    });
  });

  describe('Progress Calculation', () => {
    beforeEach(() => {
      (RoadmapService.getCurrentRoadmap as jest.Mock).mockResolvedValue(mockRoadmap);
    });

    it('should calculate and display progress percentage', async () => {
      renderWithTheme(<Roadmap onClose={mockOnClose} onOpenChat={mockOnOpenChat} />);

      await waitFor(() => {
        // 1 completed out of 3 items = 33%
        const progressText = screen.getByText(/\d+%/);
        expect(progressText).toBeInTheDocument();
      });
    });

    it('should show completed vs total goals', async () => {
      renderWithTheme(<Roadmap onClose={mockOnClose} onOpenChat={mockOnOpenChat} />);

      await waitFor(() => {
        // Should show "1/3 goals" or similar
        expect(screen.getByText(/goals/i)).toBeInTheDocument();
      });
    });
  });
});
